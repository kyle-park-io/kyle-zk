# ZK Proofs 필수 선행 학습

이 문서는 영지식 증명(Zero-Knowledge Proofs)의 고급 주제, 특히 STARKs를 이해하는 데 필요한 두 가지 핵심 기술인 Reed-Solomon 코드와 Split-and-Fold 기법에 대해 설명합니다.

## 1. Reed-Solomon (리드-솔로몬) 코드

Reed-Solomon(RS) 코드는 정보를 인코딩하여 오류를 감지하고 수정할 수 있게 하는 **오류 정정 코드(Error-Correcting Code, ECC)**의 한 종류입니다. 원래는 데이터 저장 및 통신(예: CD, QR 코드)에서 노이즈로 인한 데이터 손상을 복구하기 위해 개발되었지만, ZK 증명 시스템, 특히 STARKs에서 핵심적인 역할을 수행합니다.

### 1.1 오류 정정 코드의 기본 원리

RS 코드의 기본 아이디어는 메시지를 다항식으로 변환하는 것입니다.

1.  **인코딩 (Encoding)**:
    - **다항식 표현**: 인코딩할 데이터(메시지)를 유한체(finite field)의 원소로 간주하고, 이 점들을 지나는 특정 차수(degree)의 다항식 `P(x)`를 만듭니다. 예를 들어, `k`개의 데이터 조각이 있다면, 차수가 `k-1`인 유일한 다항식을 만들 수 있습니다.
    - **평가 (Evaluation)**: 이 다항식 `P(x)`를 `k`개보다 더 많은 `n`개의 서로 다른 지점에서 평가합니다. (예: `P(1), P(2), ..., P(n)`)
    - **코드워드 (Codeword)**: 이 `n`개의 평가 결과값의 집합이 바로 "코드워드"입니다.

2.  **오류 정정 (Error Correction)**:
    - 만약 전송 중에 일부 데이터(평가값)가 손상되더라도, 수신자는 `n`개의 점 중 최소 `k`개의 올바른 점만 있으면 원래의 `k-1` 차수 다항식 `P(x)`를 복원(보간, interpolate)할 수 있습니다.
    - 복원된 다항식을 사용하여 손상된 지점의 올바른 값을 계산하고 오류를 수정할 수 있습니다. `n-k`는 시스템이 견딜 수 있는 오류의 수를 결정합니다.

### 1.2 ZK 증명에서의 역할과 적용 (STARKs)

STARKs에서 RS 코드는 전통적인 오류 수정 목적이 아니라, **계산의 무결성(computational integrity)**을 증명하기 위한 목적으로 사용됩니다. 이 과정을 **산술화(Arithmetization)** 및 **LDE(Low-Degree Extension)**라고 부릅니다.

1.  **산술화 (Arithmetization)**:
    - 증명하려는 계산 과정(예: 프로그램 실행)의 각 단계를 **실행 추적(execution trace)**이라는 데이터로 표현합니다.
    - 이 실행 추적을 유한체의 점들로 간주하여, 이 점들을 모두 통과하는 낮은 차수(low-degree)의 다항식 `P(x)`를 만듭니다. 만약 계산이 올바르게 수행되었다면, 이 실행 추적은 특정 대수적 제약 조건을 만족하며, 이는 결과적으로 낮은 차수의 다항식으로 표현될 수 있습니다.

2.  **LDE (Low-Degree Extension)**:
    - 증명자(Prover)는 이 다항식 `P(x)`를 실행 추적의 길이(`k`)보다 훨씬 더 큰 평가 도메인(`n`)에서 평가하여 코드워드를 생성합니다. 이 과정이 바로 Reed-Solomon 인코딩입니다.
    - **오류 증폭**: 만약 증명자가 계산을 속이려 했다면(즉, 실행 추적이 올바르지 않다면), 그 결과 생성된 다항식은 더 이상 낮은 차수가 아니게 됩니다. 이 "잘못된" 다항식을 큰 도메인에서 평가하면, 올바른 코드워드와는 매우 다른, 즉 거리가 "먼" 값을 갖게 됩니다. 이처럼, 작은 오류가 LDE를 통해 큰 차이로 증폭됩니다.

3.  **FRI 프로토콜**:
    - 증명자는 이 LDE로 생성된 코드워드를 Merkle 트리로 해싱하여 **커밋(commit)**합니다.
    - 검증자(Verifier)는 증명자에게 이 커밋된 함수가 실제로 낮은 차수의 다항식에서 왔다는 것을 증명하라고 요구합니다.
    - **FRI (Fast Reed-Solomon Interactive Oracle Proof of Proximity)** 프로토콜은 증명자가 다항식 자체를 공개하지 않으면서도, 해당 커밋이 낮은 차수 다항식의 코드워드에 "가깝다(proximate)"는 것을 효율적으로 증명할 수 있게 해줍니다. 이 과정의 핵심이 바로 아래에서 설명할 **Split-and-Fold** 기법입니다.

## 2. STARK 기법 중 Split-and-Fold

Split-and-Fold는 FRI 프로토콜의 핵심적인 재귀(recursive) 단계입니다. 이 기법의 목적은 **"어떤 함수(다항식)가 낮은 차수(low-degree)를 갖는다는 주장"**을 **"그보다 훨씬 작은 차수를 갖는 다른 함수에 대한 주장"**으로 효율적으로 변환하는 것입니다. 이 과정을 반복하여 검증을 매우 간단하게 만듭니다.

### 2.1 다항식 Commitment 과정

1.  증명자는 낮은 차수 `d`를 갖는 다항식 `f(x)`가 있다고 주장합니다.
2.  증명자는 이 다항식 `f(x)`를 특정 도메인에서 평가하고, 그 결과값들을 Merkle 트리에 넣어 커밋합니다. 검증자는 이 트리의 루트 해시만 받습니다.
3.  이제 검증자는 이 Merkle 루트가 정말로 차수 `d` 이하인 다항식 `f(x)`의 평가값들로 만들어졌는지 확인해야 합니다.

### 2.2 검증 과정의 효율성 개선 원리 (Split-and-Fold)

검증자가 모든 평가값을 받아 다항식의 차수를 직접 확인하는 것은 매우 비효율적입니다. Split-and-Fold는 무작위 샘플링을 통해 이 과정을 효율적으로 만듭니다.

1.  **분할 (Split)**:
    - 증명자는 차수 `d`인 다항식 `f(x)`를 짝수 차수 항들과 홀수 차수 항들로 분리하여 두 개의 새로운 다항식 `g(y)`와 `h(y)`를 만듭니다. 이들은 원래 다항식 차수의 거의 절반(`≈ d/2`)이 됩니다.
    - `f(x) = f_even(x^2) + x \cdot f_odd(x^2)`
    - 여기서 `g(y) = f_even(y)` 이고 `h(y) = f_odd(y)` 입니다. (`y = x^2`)

2.  **결합 (Fold)**:
    - 검증자는 무작위 값(random challenge) `α` (알파)를 선택하여 증명자에게 보냅니다.
    - 증명자는 `α`를 사용하여 두 개의 절반 차수 다항식 `g(y)`와 `h(y)`를 선형 결합하여 새로운 다항식 `f'(y)`를 만듭니다.
    - `f'(y) = g(y) + α \cdot h(y)`
    - 이 새로운 다항식 `f'(y)`의 차수는 `g(y)`와 `h(y)`의 차수와 거의 같으므로, 원래 다항식 `f(x)`의 차수의 약 절반(`≈ d/2`)이 됩니다.
    - 증명자는 이 새로운 다항식 `f'(y)`에 대해 다시 커밋합니다.

3.  **재귀 (Recursion)**:
    - 이제 원래의 문제("`f(x)`의 차수가 `d` 이하인가?")는 더 작은 문제("`f'(y)`의 차수가 `d/2` 이하인가?")로 축소되었습니다.
    - 이 **Split-and-Fold** 과정을 다항식의 차수가 0(즉, 상수가 될 때)에 도달할 때까지 재귀적으로 반복합니다.
    - 매 단계마다 검증자는 새로운 무작위 `α`를 제공하고, 증명자는 다항식의 차수를 절반으로 줄여서 다시 커밋합니다.

4.  **최종 검증**:
    - 여러 번의 재귀 끝에 다항식은 결국 하나의 상수(constant)가 됩니다. 증명자는 이 상수 값을 공개합니다.
    - 검증자는 전체 과정(모든 커밋 포함)과 최종 상수 값을 바탕으로 몇 가지 무작위 지점에서만 검사를 수행하여 전체 주장이 높은 확률로 참임을 확신할 수 있습니다. 만약 증명자가 어느 한 단계에서라도 속였다면, 무작위 검사를 통과할 확률이 매우 낮아집니다.

이러한 재귀적 차수 축소 덕분에 검증자는 전체 다항식을 보지 않고도 매우 적은 양의 통신과 계산만으로 증명을 검증할 수 있으며, 이는 STARK의 확장성(scalability)과 효율성의 핵심 원리입니다.
